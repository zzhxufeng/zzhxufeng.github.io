{"meta":{"title":"Blog","subtitle":"","description":"","author":"zzhxufeng","url":"https://zzhxufeng.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-12-22T07:57:02.676Z","updated":"2021-12-22T07:50:49.295Z","comments":false,"path":"/404.html","permalink":"https://zzhxufeng.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-22T07:57:02.680Z","updated":"2021-12-22T07:50:49.295Z","comments":false,"path":"about/index.html","permalink":"https://zzhxufeng.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-12-22T07:57:02.680Z","updated":"2021-12-22T07:50:49.295Z","comments":false,"path":"books/index.html","permalink":"https://zzhxufeng.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-22T07:57:02.680Z","updated":"2021-12-22T07:50:49.295Z","comments":false,"path":"categories/index.html","permalink":"https://zzhxufeng.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-22T07:57:02.680Z","updated":"2021-12-22T07:50:49.295Z","comments":false,"path":"repository/index.html","permalink":"https://zzhxufeng.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-22T07:57:02.680Z","updated":"2021-12-22T07:50:49.295Z","comments":true,"path":"links/index.html","permalink":"https://zzhxufeng.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-22T07:57:02.680Z","updated":"2021-12-22T07:50:49.295Z","comments":false,"path":"tags/index.html","permalink":"https://zzhxufeng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"反射","slug":"反射","date":"2022-02-25T13:31:54.000Z","updated":"2022-02-25T13:38:14.189Z","comments":true,"path":"2022/02/25/反射/","link":"","permalink":"https://zzhxufeng.github.io/2022/02/25/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射的目的在运行时，对某个实例一无所知的情况下调用其方法。 什么是反射SomeClass.java -&gt; SomeClass.class -&gt; Class jvmcls = new Class(SomeClass) 除基本数据类型外，其它类型都是class（包括interface） Class实例在JVM中是唯一的 class是由JVM在执行过程中动态加载的，JVM在第一次读取到一种class类型时，将其加载进内存。每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来 由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等 因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。这就被称为反射。 如何获取class信息 Class cls = String.class Class cls = s.getClass() Class cls = Class.forName(“java.lang.String”) 调用方法 获取Class对象 通过方法名和参数类型列表获取方法对象 method.invoke(实例, 参数列表) 公有方法 12345678910111213141516171819202122public class UsingReflection &#123; public int add(int a, int b) &#123; return a + b; &#125; public static void main(String args[]) &#123; try &#123; Class cls = Class.forName(&quot;pers.xf.learn.jlang.reflection.UsingReflection&quot;); Method meth = cls.getMethod(&quot;add&quot;, Integer.TYPE, Integer.TYPE); UsingReflection obj = new UsingReflection(); Integer res = (Integer) meth.invoke(obj, new Object[]&#123;new Integer(33), new Integer(44)&#125;); System.out.println(res.intValue()); &#125; catch (Throwable e) &#123; System.err.println(e); &#125; &#125;&#125;// output: 77 私有方法 12// ...method.setAccessible(true); 类方法 12method = Integer.class.getMethod(&quot;parseInt&quot;, String.class);method.invoke(null, &quot;123&quot;); 参考 Using Java Reflection 反射","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://zzhxufeng.github.io/tags/Java/"}]},{"title":"AOSP build, flash","slug":"AOSP-build-flash","date":"2022-01-10T13:30:31.000Z","updated":"2022-01-11T12:57:06.959Z","comments":true,"path":"2022/01/10/AOSP-build-flash/","link":"","permalink":"https://zzhxufeng.github.io/2022/01/10/AOSP-build-flash/","excerpt":"","text":"前提 Pixel4 frame Ubuntu18.04, SSD 500GB, RAM 32GB AOSP build env 下载驱动及AOSP驱动和AOSP的build ID要对应。 Driver Binaries for Nexus and Pixel Devices 下载源代码 准备驱动及编译AOSP 将驱动脚本解压到AOSP源码根目录下 执行两个驱动脚本 编译AOSP， pixel4 aosp_flame-userdebug 烧写 export ANDROID_PRODUCT_OUT=out/target/product/flame adb reboot bootloader fastboot flashall -w （wipes /data) fastboot reboot 参考 Flashing Devices | Android Open Source Project AOSP 编译和烧写","categories":[],"tags":[{"name":"AOSP","slug":"AOSP","permalink":"https://zzhxufeng.github.io/tags/AOSP/"}]},{"title":"Android可执行文件构建过程","slug":"Android可执行文件构建过程","date":"2022-01-02T14:02:06.000Z","updated":"2022-01-02T15:12:22.883Z","comments":true,"path":"2022/01/02/Android可执行文件构建过程/","link":"","permalink":"https://zzhxufeng.github.io/2022/01/02/Android%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/","excerpt":"","text":"在构建过程中，Android项目会被编译并打包进一个 .apk 文件。 .apk 文件实际上就是一个 .zip 压缩包。每个 .apk 文件包括一个 classes.dex 文件，这是Dalvik虚拟机的可执行文件。 .apk 中包括： .dex 文件：.class 文件转换成的Dalvik字节码 AndroidManifest.xml 文件会被编译成二进制版本 编译过的资源文件 resources.arsc 不经编译的资源文件 一个项目经过编译、打包、签名： 具体过程： 首先，Android Asset Packaging Tool(aapt) 工具将资源文件编译。资源文件包括 AndroidManifest.xml 以及其他的一些 XML 文件。这将生成一个 R.java 的类，然后我们可以通过 R 类从 Java 代码中引用资源文件。 aidl 工具将 .aidl 文件转换成 Java 接口。 将所有的 Java 代码通过 Java 编译器编译成 .class 文件。在这一步中编译 src 目录下的所有 Java 文件，生成的文件位于 bin/classes 目录下。 dex 工具将 .class 文件以及三方代码库转换成 Dalvik 二进制代码，生成一个 .dex 文件。将 Java 字节码转换成 Dalvik 字节码，压缩常量池、消除冗余信息。 所有那些没被编译的资源文件（比如图片）、被编译了的资源文件以及 .dex 文件都通过 apkbuilder 工具最后打包成一个 .apk 文件。.apk 文件在发布前还需要进行签名。debug也需要debug的签名。 最后还需要对签名后的 .apk 进行 align （对齐）处理。它的主要工作是使 apk 包中所有资源文件距离文件起始偏移4字节的整数倍，这样通过内存映射访问 apk 文件时速度会更快。 aapt 位于 android-sdk/platform-tools 目录下。该工具的源码在 frameworks/base/tools/aapt 目录下，生成过程的主要入口在 aapt 源码目录下的 Resource.cpp 的 buildResources() 函数。 aidl 工具在 android-sdk/platform-tools 目录下。工具源码在 frameworks/base/tools/aidl 目录。 签名工具有 JDK 提供的 jarsigner 工具，还有 Android 源码中提供的 signapk 工具，其代码位于 build/tools/signapk。 引用： Building and Running 《Android软件安全与逆向分析》","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://zzhxufeng.github.io/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-12-22T07:47:43.358Z","updated":"2021-12-22T07:47:43.358Z","comments":true,"path":"2021/12/22/hello-world/","link":"","permalink":"https://zzhxufeng.github.io/2021/12/22/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://zzhxufeng.github.io/tags/Java/"},{"name":"AOSP","slug":"AOSP","permalink":"https://zzhxufeng.github.io/tags/AOSP/"},{"name":"Android","slug":"Android","permalink":"https://zzhxufeng.github.io/tags/Android/"}]}